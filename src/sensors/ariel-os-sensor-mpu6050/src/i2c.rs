//! Driver for the sensor used over I2C.
//!

use ariel_os_sensors::{
    Label, MeasurementUnit, Sensor,
    sensor::{
        Mode as SensorMode, ReadingChannel, ReadingChannels, ReadingError, ReadingWaiter, Samples,
        SetModeError, State, TriggerMeasurementError,
    },
    signal::Signal as ReadingSignal,
};

use embassy_time::Delay;

use ariel_os_sensors::{
    Category,
    sensor::{ReadingResult, Sample, SampleMetadata},
};
use ariel_os_sensors_utils::AtomicState;
use embassy_sync::{blocking_mutex::raw::CriticalSectionRawMutex, once_lock::OnceLock};
use embassy_sync::{mutex::Mutex, signal::Signal};
use embedded_hal_async::i2c::I2c;

use mpu6050_async::Mpu6050 as DriverMpu6050;

use crate::{ACC_SCALING, GYR_SCALING, PART_NUMBER, TEMP_SCALING};

ariel_os_hal::define_peripherals!(
    /// Peripherals required by the sensor driver.
    Peripherals {}
);

/// Driver to use an MPU6050 sensor over I2C.
pub struct Mpu6050Sensor<I2C> {
    state: AtomicState,
    label: Option<&'static str>,
    device: OnceLock<Mutex<CriticalSectionRawMutex, DriverMpu6050<I2C>>>,
    signaling: Signal<CriticalSectionRawMutex, ()>,
    reading: ReadingSignal<ReadingResult<Samples>>,
}

impl<I2C: I2c + Send> Mpu6050Sensor<I2C> {
    /// Creates an uninitialized MPU6050 sensor driver.
    #[must_use]
    pub const fn new(label: Option<&'static str>) -> Self {
        Self {
            state: AtomicState::new(State::Uninitialized),
            label,
            device: OnceLock::new(),
            signaling: Signal::new(),
            reading: ReadingSignal::new(),
        }
    }

    /// Initializes the driver.
    pub async fn init(&'static self, _peripherals: Peripherals, i2c_device: I2C) {
        if !self.device.is_set() {
            let dev = DriverMpu6050::new(i2c_device);
            if self.device.init(Mutex::new(dev)).is_err() {
                return;
            }
        }
        let mut dev = self.device.get().await.lock().await;
        dev.init(&mut Delay).await.unwrap();
        self.state.set(State::Enabled);
    }

    /// Listens for measurement requests generated by [`Mpu6050::trigger_measurement()`] and
    /// responds to them.
    /// This should be called before [`Mpu6050::wait_for_reading()`], as that method will otherwise
    /// not be able to respond to measurement requests from [`Mpu6050::trigger_measurement()`].
    ///
    /// # Note
    ///
    /// [`Mpu6050::init()`] needs to be called and `await`ed before calling this method.
    pub async fn run(&'static self) -> ! {
        loop {
            self.signaling.wait().await;

            self.reading.signal(self.measure().await);
        }
    }
    /// Triggers a measurement and asynchronously returns the readings when available.
    ///
    /// # Errors
    ///
    /// Returns `ReadingError::SensorAccess` in case of a communication error with the sensor
    /// device.
    pub async fn measure(&'static self) -> ReadingResult<Samples> {
        let mut dev = self.device.get().await.lock().await;
        let mut acc = match dev.get_acc().await {
            Ok(v) => v,
            Err(_) => return Err(ReadingError::SensorAccess),
        };
        let mut gyro = match dev.get_gyro().await {
            Ok(v) => v,
            Err(_) => return Err(ReadingError::SensorAccess),
        };

        let mut temp = match dev.get_temp().await {
            Ok(v) => v,
            Err(_) => return Err(ReadingError::SensorAccess),
        };

        Ok(Samples::from_7(
            self,
            [
                Sample::new(
                    f32_to_i32_scaled(acc.x, ACC_SCALING),
                    SampleMetadata::SymmetricalError {
                        deviation: 85,
                        bias: 0,
                        scaling: -3,
                    },
                ),
                Sample::new(
                    f32_to_i32_scaled(acc.y, ACC_SCALING),
                    SampleMetadata::SymmetricalError {
                        deviation: 85,
                        bias: 0,
                        scaling: -3,
                    },
                ),
                Sample::new(
                    f32_to_i32_scaled(acc.z, ACC_SCALING),
                    SampleMetadata::SymmetricalError {
                        deviation: 140,
                        bias: 0,
                        scaling: -3,
                    },
                ),
                Sample::new(
                    f32_to_i32_scaled(gyro.x, GYR_SCALING),
                    SampleMetadata::SymmetricalError {
                        deviation: 40,
                        bias: 0,
                        scaling: -3,
                    },
                ),
                Sample::new(
                    f32_to_i32_scaled(gyro.y, GYR_SCALING),
                    SampleMetadata::SymmetricalError {
                        deviation: 40,
                        bias: 0,
                        scaling: -3,
                    },
                ),
                Sample::new(
                    f32_to_i32_scaled(gyro.z, GYR_SCALING),
                    SampleMetadata::SymmetricalError {
                        deviation: 40,
                        bias: 0,
                        scaling: -3,
                    },
                ),
                Sample::new(
                    f32_to_i32_scaled(temp, TEMP_SCALING),
                    SampleMetadata::SymmetricalError {
                        deviation: 1,
                        bias: 0,
                        scaling: 0,
                    },
                ),
            ],
        ))
    }
}

impl<I2C: Send> Sensor for Mpu6050Sensor<I2C> {
    fn trigger_measurement(&self) -> Result<(), TriggerMeasurementError> {
        self.reading.clear();

        match self.state.get() {
            State::Measuring => {}
            State::Enabled => {
                self.state.set(State::Measuring);
            }
            State::Uninitialized | State::Disabled | State::Sleeping => {
                return Err(TriggerMeasurementError::NonEnabled);
            }
        }

        self.signaling.signal(());

        Ok(())
    }

    fn wait_for_reading(&'static self) -> ReadingWaiter {
        match self.state.get() {
            State::Measuring => {
                self.state.set(State::Enabled);

                ReadingWaiter::new(self.reading.wait())
            }
            State::Enabled => ReadingWaiter::new_err(ReadingError::NotMeasuring),
            State::Uninitialized | State::Disabled | State::Sleeping => {
                ReadingWaiter::new_err(ReadingError::NonEnabled)
            }
        }
    }

    fn set_mode(&self, mode: SensorMode) -> Result<State, SetModeError> {
        let new_state = self.state.set_mode(mode);

        if new_state == State::Uninitialized {
            Err(SetModeError::Uninitialized)
        } else {
            Ok(new_state)
        }
    }

    fn state(&self) -> State {
        self.state.get()
    }

    fn categories(&self) -> &'static [Category] {
        &[Category::AccelerometerGyroscope]
    }

    fn reading_channels(&self) -> ReadingChannels {
        ReadingChannels::from([
            ReadingChannel::new(Label::AccelerationX, ACC_SCALING, MeasurementUnit::AccelG),
            ReadingChannel::new(Label::AccelerationY, ACC_SCALING, MeasurementUnit::AccelG),
            ReadingChannel::new(Label::AccelerationZ, ACC_SCALING, MeasurementUnit::AccelG),
            ReadingChannel::new(
                Label::AngularVelocityX,
                GYR_SCALING,
                MeasurementUnit::DegreePerSecond,
            ),
            ReadingChannel::new(
                Label::AngularVelocityY,
                GYR_SCALING,
                MeasurementUnit::DegreePerSecond,
            ),
            ReadingChannel::new(
                Label::AngularVelocityZ,
                GYR_SCALING,
                MeasurementUnit::DegreePerSecond,
            ),
            ReadingChannel::new(Label::Temperature, TEMP_SCALING, MeasurementUnit::Celsius),
        ])
    }

    fn label(&self) -> Option<&'static str> {
        self.label
    }

    fn display_name(&self) -> Option<&'static str> {
        Some("Some gyroscope and accelerometer")
    }

    fn part_number(&self) -> Option<&'static str> {
        Some(PART_NUMBER)
    }

    fn version(&self) -> u8 {
        0
    }
}

/// Converts a f32 value to an i32 value, scaled by a given factor.
/// Assumption:
/// - Value is in the range of i32::MAX / 10.0
pub fn f32_to_i32_scaled(x: f32, scaling: i8) -> i32 {
    let mut factor = 1.0_f32;
    let exp = -(scaling as i16);
    if exp >= 0 {
        for _ in 0..(exp as u16) {
            factor *= 10.0;
        }
    } else {
        for _ in 0..((-exp) as u16) {
            factor /= 10.0;
        }
    }

    let y = x * factor;
    let y = y + if y >= 0.0 { 0.5 } else { -0.5 };

    y as i32
}
